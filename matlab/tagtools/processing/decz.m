function      [y,Z,X] = decz(x,Z)

%     [y,z] = decz(x,df)
%		or
%		[y,Z] = decz(x,Z)
%		Recursive sampling rate decimator. This is a version of decdc
%		that can be run iteratively over a long data set, e.g., to
%		decimate an entire recording that is too large to be read into
%		memory. See wavdec() for a use of this function to decimate an
%		entire WAV format file.
%     The first time decz is called, use the following format:
%		  y = decz(x,df) ; 
%     The subsequent calls to decz for contiguous input data are:
%		 [y,z] = decz(x,z)
%     The final call when there is no more input data is:
%		 y = decz([],z)
%	   Each output y in the above contains a segment of the decimated
%		signal and so these need to be concatenated. See example below.
%
%		Inputs:
%		x is a vector or matrix containing the signal(s) to be decimated.
%		 If x is a matrix, each column is decimated separately.
%		df is the decimation factor. The output sampling rate is the input
%		 sampling rate divided by df. df must be an integer greater than 1.
%		 df can also be a three element vector in which case:
%      df(1) is the decimation factor
%      df(2) is the number of output samples spanned by the filter (default
%		  value is 12). A larger value makes the filter steeper.
%      df(3) is the fractional bandwidth of the filter (default value is 
%		  0.8) relative to the output Nyquist frequency. If df(2) is greater than
%		  12, df(3) can be closer to 1.
%		Z is the 'state' structure that is generated by a previous call to
%		 decz. This is how the function keeps track of filter internal values
%		 (i.e., memory) from call-to-call.
%
%		Returns:
%		y is the decimated signal vector or matrix. It has the same number
%		 of columns as x but has, on average, 1/df of the rows.
%
%     Decimation is performed in the same way as for decdc. The group delay of the
%		filter is removed. For large decimation factors (e.g., df>>50), it is better 
%		to perform several nested decimations with lower factors.
%
%		Example:
%		Assuming you have a function called 'load_next_block' which reads in the next
%		piece of a contiguous input data stream, decimate as follows:
%		z = 4 ;					% set the decimation factor
%		Y = [] ;
%	   x = load_next_block ;
%		while ~isempty(x),
% 		  [y,z]=decz(x,z);
%		  Y(end+(1:size(y,1)),1:size(y,2)) = y ;
%		  x = load_next_block ;
%		end
% 		y=decz([],z);
%		Y(end+(1:size(y,1)),1:size(y,2)) = y ;
%
%     Valid: Matlab, Octave
%     markjohnson@st-andrews.ac.uk
%     last modified: June 2017

nf = 12 ;         % filter length is nf*df
frbw = 0.8 ;      % bandwidth of filter relative to new Nyquist

if ~isstruct(Z),
   if length(Z)>=2,
      nf = Z(2) ;
      if length(Z)>=3,
         frbw = Z(3) ;
      end
   end

   df = Z(1) ;
   Z = struct('df',df) ;
   Z.h = fir1(df*nf,frbw/df) ;
   nh = length(Z.h) ;
   Z.n = nh ;
   % below number carefully chosen to precisely match to decdc.
   % do not change!
   npre = floor(df*(nf-1)/2-1) ;
   
   %Z.z = [2*x(1,:)-x(1+(nh-df-npre:-1:1),:);x(1:npre,:)] ;
   % above line fixed to following (SDR 25/7/17)
   Z.z = [repmat(2*x(1,:),nh-df-npre,1) - x(1+(nh-df-npre:-1:1),:);x(1:npre,:)] ;

   Z.ov = [] ;
   x = x(npre+1:end,:) ;
end

nh = Z.n ;
df = Z.df ;
if isempty(x),
   % reuse the last few inputs to squeeze some more output
   % from the filter.
   x = [Z.z;Z.ov] ;
   % below number carefully chosen to give same number of
   % samples as decdc on test samples. do not change!
   npre = floor(df*(nf-1)/2-1) ;
   x = [Z.ov;2*x(end,:)-x(end-(1:npre-1),:)] ;
elseif ~isempty(Z.ov),
   x = [Z.ov;x] ;
end

Z.ov = [] ;
for k=1:size(x,2),
   %[X,zz,z] = buffer(x(:,k),nh,nh-df,Z.z(:,k)) ;
   [X,zz,z] = buffer([Z.z(:,k);x(:,k)],nh,nh-df,'nodelay') ;
   if k==1,
      y = zeros(size(X,2),size(x,2)) ;
   end
   y(:,k) = (Z.h*X)' ;
   Z.z(:,k) = z ;
   if isempty(Z.ov),
      Z.ov = zeros(length(zz),size(x,2)) ;
   end
   Z.ov(:,k) = zz ;
end
return

