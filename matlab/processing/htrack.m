function    [T,pe] = htrack(A,M,s,fs,fc)

%    T=htrack(A,M,s,fs)			% A and M are matrices
%	  or
%    T=htrack(A,M,s,fs,fc)		% A and M are matrices
%	  or
%    T=htrack(A,M,s)				% A and M are sensor structures
%	  or
%    T=htrack(A,M,s,fc)			% A and M are sensor structures
%    Simple horizontal dead-reckoned track (pseudo-track) estimation based on speed
%	  and heading. This differs from ptrack in that the animal's body angle is not
%	  considered. This makes it appropriate for animals that do not always move in the
%	  direction of their longitudinal axis.
%
%	  Inputs:
%    A is a nx3 acceleration matrix with columns [ax ay az]. Acceleration can 
%		be in any consistent unit, e.g., g or m/s^2. 
%    M is the magnetometer signal matrix, M=[mx,my,mz] in any consistent unit
%		(e.g., in uT or Gauss). A and M must have the same size (and so are both 
%		measured at the same sampling rate).
%    s is the forward speed of the animal in m/s. s can be a single number meaning 
%		that the animal is assumed to travel at a constant speed. s can also be a vector
%		with the same number of rows as M, e.g., generated by ocdr.
%    fs is the sampling rate of the sensor data in Hz (samples per second).
%	  fc (optional) specifies the cut-off frequency of a low-pass filter to
%		apply to A and M before computing heading. The filter cut-off frequency is 
%	   in Hz. The filter length is 4*fs/fc. Filtering adds no group delay. If fc is 
%		empty or not given, the default value of 0.2 Hz (i.e., a 5 second time constant) is used.
%
%    Returns:
%	  T is the estimated track in a local level frame. The track is defined as meters
%		of northward and eastward movement (termed 'northing' and 'easting', i.e, 
%		T=[northing,easting]) relative to the animal's position at the start of the measurements 
%		(which is defined as [0,0]). The track sampling rate is the same as for the input data and
%		so each row of T defines the track coordinates at times 0,1/fs,2/fs,... relative to the
%		start time of the measurements.
%
%	  Frame: This function assumes a [north,east,up] navigation frame and a
%	  [forward,right,up] local frame. Both A and M must be rotated if needed to match the
%	  animal's cardinal axes otherwise the track will not be meaningful. Use rotframe() to
%	  achieve this. Unless the local declination angle is also corrected with rotframe, the dead-
%	  reckoned track will use magnetic north rather than true north.
%
%    CAUTION: dead-reckoned tracks are usually very inaccurate. They are useful to get an
%	  idea of HOW animals move rather than WHERE they go. Few animals probably travel in exactly
%	  the direction of their longitudinal axis and anyway measuring the precise orientation of the
%	  longitudinal axis of a non-rigid animal is fraught with error. Moreover, if there is net flow
%	  in the medium, the animal will be advected by the flow in addition to its autonomous movement.
%	  For swimming animals this can lead to substantial errors. The forward speed is assumed to be 
%	  with respect to the medium so the track derived here is NOT the 'track-made-good', i.e., the
%	  geographic movement of the animal. It estimates the movement of the animal with respect to the
%	  medium. There are numerous other sources of error so use at your own risk!
%
%	  Example:
%       load_nc('testset1')
%       fs = P.sampling_rate;
%		v = ocdr(P,A);
%		s = sqrt(max(1-v.^2,0));
%		T = htrack(A,M,s);
%       figure
%       xlabel('Easting, m')
%       ylabel('Northing, m')
%       title('Dead-Reckoned Track')
%       hold on
%       plot(T(:,2),T(:,1))
% 	   returns: A plot of the track in a local-level frame.
%
%    Valid: Matlab, Octave
%    markjohnson@st-andrews.ac.uk
%    Last modified: 3 March 2018 - added interpolation over NaN input values
%              - fixed bug when inputs are sensor structures   

T = [] ; pe = [] ;
if nargin<3,
   help htrack
   return
end

if isstruct(M) && isstruct(A),
	if nargin>3,
		fc = fs ;
	else
		fc = [] ;
	end
	[A,M,fs] = sens2var(A,M,'regular') ;
	if isempty(A),	return, end
else
	if nargin<4,
		help htrack
		return
	end
	if nargin<5,
		fc = [] ;
	end
end

if isempty(fc),
   fc = 0.2 ;
end

% if there are any outages (NaNs) in A or M, interpolate over these and
% remember the interpolated points to remove them from the DR track later
[A,ka] = interpnan(A) ;
[M,km] = interpnan(M) ;

nf = 4*fs/fc ;
hd = m2h(M,A,fs,fc);
if length(s)==1,
	s = repmat(s/fs,size(hd,1),2) ;
else
   [s,ks] = interpnan(s) ;
	s = repmat(s/fs,1,2) ;
end
	
T = cumsum(s.*[cos(hd) sin(hd)]) ;
T(ka,:) = repmat(NaN,length(ka),2) ;
T(km,:) = repmat(NaN,length(km),2) ;
T(ks,:) = repmat(NaN,length(ks),2) ;
return


function  [x,k] = interpnan(x)
%
if size(x,1)==1,     % make sure x is a column vector if not a matrix
   x = x(:) ;
end

nx = any(isnan(x),2) ;     % find the outages
k = find(nx) ;             % remember their indices

if nx(1)==1,         % if there is an outage at the start, just fill with duplicate values
   kg = find(nx==0,1) ;    % find the first good value
   x(1:kg-1,:) = repmat(x(kg,:),kg-1,1) ; % and duplicate it
end

if nx(end)==1,       % same if there is an outage at the end
   kg = find(nx==0,1,'last') ;    % find the last good value
   x(kg+1:end,:) = repmat(x(kg,:),size(x,1)-kg,1) ;   % and duplicate it
end

nx = any(isnan(x),2) ;     % now do remaining outages
while sum(nx)>0,
   ki = find(nx==1,1) ;    % find the next outage start
   kg = ki-1+find(nx(ki:end)==0,1) ;   % find the first good value after the outage
   x(ki:kg-1,:) = interp1([0;kg-ki+1],x([ki-1;kg],:),(1:kg-ki)') ;
   nx = any(isnan(x),2) ;
end
return
