def sens_struct(data=None,fs=None,depid=None,sens_type=None,name=None,ordered=False):
    
    """
    Generate a sensor structure from a sensor data list or array.
    
       X = sens_struct(data,fs,depid)  % regularly sampled data
       or
       X = sens_struct(data,T,depid)   % irregularly sampled data
       or
       X = sens_struct(data,fs,depid,sens_type)  % regularly sampled data
       or
       X = sens_struct(data,T,depid,sens_type)   % irregularly sampled data
       or
       X = sens_struct(data,fs,depid,sens_type,name)  % regularly sampled data
       or
       X = sens_struct(data,T,depid,sens_type,name)   % irregularly sampled data
       
       Inputs:
       :param data: is a list of sensor data. This can be in any unit and frame but the metadata generated by sens_struct assumes a default
           unit and frame. Change these manually in X after running sens_struct to the correct unit and frame.
        :type: list
       :param fs: is the sampling rate of the sensor data in Hz (samples per second).
       :type: scalar
       :param T: is the time in seconds of each measurement in data for irregularly sampled data. The time reference (i.e., the 0 time) should be with
           respect to the start time of the deployment.
       depid is a string containing the deployment identifier for these data.
       sens_type is a string containing the first few letters of the sensor type, e.g., acc for acceleration. These will be matched to the list of
           sensor names in the sensor_names.csv file. If more than one sensor matches type, a list of matches will be shown and you will be prompted
           to select one. sens_type can be in upper or lower case. If sens_type is not given or is empty, a list of all defined sensor types will be
           displayed for selection.
       name is the optional name to give the variable, e.g., T_EXT. If a name is not given, a default value will be selected.

       Returns:
       X is a sensor dictionary with metadata fields pre-populated from the sensor_names.csv file. Change these as needed to the correct values.
           X's keys can optionally be sorted alphabetically if ordered is set to True

       Example:
        A = sens_struct(Aw,fs,'md13_134a','acc')
        A.frame = 'animal' ;     % change frame indication

       Valid: Python
       markjohnson@st-andrews.ac.uk; dmwisniewska@gmail.com
       Last modified: 07/07/2021
    
    """
    
    import numpy as np
    import pandas as pd
    import os
    
    X = {}
        
    if not data or not fs or not depid:
        print(help(sens_struct))
        S = pd.read_csv(os.path.join(os.path.dirname(os.path.abspath(__file__)),'sensor_names.csv'))
        print('Predefined sensor types:\n')
        for sens in S.name:
            print(sens)
        return X

    # elif all((data, fs, depid)) and not sens_type:
    #     sens_type = None
    
    if not hasattr(fs, "__len__"): # regularly sampled data
        X['data'] = np.array(data)
        X['sampling'] = 'regular'
        X['sampling_rate'] = fs 
        X['sampling_rate_unit'] = 'Hz'
    else:                          # irregular data
        if len(fs) != len(data):
            print(' Error: number of sampling times does not match number of samples\n')
            return X  
        X['data'] = np.hstack((fs,data))
        X['sampling'] = 'irregular'
        X['sampling_rate'] = 'column 1' 
        X['sampling_rate_unit'] = 'second'
        fs = None
        
    X['depid'] = depid

    from datetime import datetime
    X['creation_date'] = datetime.now().strftime("%d-%b-%Y %H:%M:%S")
    X['history'] = 'sens_struct'

    # read in sensor names database and compare against sens_type
    S = pd.read_csv(os.path.join(os.path.dirname(os.path.abspath(__file__)),'sensor_names.csv'))
    if not sens_type:
        k = np.arange(0,len(S))
    else:
        k = [i for i,x in enumerate(S.name) if x.lower().startswith(sens_type.lower())]
        if not k:
            k = [i for i,x in enumerate(S.type) if x.lower().startswith(sens_type.lower())]
    if not k:
        print(f" Warning: unknown sensor type {sens_type}. Set metadata manually\n")
        X['name'] = sens_type
        X['type'] = sens_type
        return X
    
    if len(k)>1:
        print(f" Multiple sensor types match {sens_type}:\n")  
        for kk in range(0,len(k)):
            print(f" {kk} {S.name[k[kk]]}")
        n = input(' Enter number of correct type... ') 
        n = int(n)
        import math
        if not n or math.isnan(n) or n<0 or n>len(k)-1:
            X = {}
            return X
        k = k[n]
    else:
        k = k[0] 
    
    nc = S['axes'][k]
    if data and np.array(data).shape[1]!=nc:
        print(f" Warning: size of data does not match number of columns ({nc}) expected for {S.name[k]}\n")
       
    if not name:
        X['name'] = S.abbrev[k]
    else:
        X['name'] = name
    
    X['type'] = S.type[k]
    X['full_name'] = S.name[k]
    X['description'] = S.description[k]
    X['unit'] = S.def_units[k]
    X['unit_name'] = S.def_unit_name[k]
    X['unit_label'] = S.def_label[k]
    X['start_offset'] = 0
    X['start_offset_units'] = 'second'
    
    if S.def_cols[k] and isinstance(S.def_cols[k], str):
        from .strip_quotes import strip_quotes
        if not fs:
            X['column_name'] = 'time,' + strip_quotes(S.def_cols[k])
        else:
            X['column_name'] = strip_quotes(S.def_cols[k])
            
    if S.def_frame[k] and isinstance(S.def_frame[k],str):
        X['frame'] = S.def_frame[k]
        
    if S.def_axes[k] and isinstance(S.def_axes[k],str):
        X['axes'] = S.def_axes[k]
    
    
    if ordered:
        Y = {}
        for i in sorted(X):
            Y[i] = X[i]
        return Y
    else:
        return X